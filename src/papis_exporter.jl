"""
$(SIGNATURES)

Export a `BibInternal.jl` entry to Papis, handling some edge cases (duplicates, files not existing...)
"""
function export_bibinternal(entry, tags, files; papis_root, move_external, append_zotero_id_on_duplicate)
    filepath = papis_directory(papis_root, entry.date.year, entry.id)
    if isdir(filepath) && append_zotero_id_on_duplicate
        filepath = papis_directory(papis_root, entry.date.year, entry.id * "_" * entry.fields["id"])
    end
    if isdir(filepath)
        @warn "Unresolved duplicate." filepath
    end
    mkpath(filepath)
    dict = OrderedDict(
        "ref" => entry.id,
        "title" => entry.title,
        "bookTitle" => entry.booktitle,
        "author" => Bibliography.names_to_strings(entry.authors),
        "type" => entry.type,
        "files" => String[],
    )
    Bibliography.in_to_bibtex!(dict, entry.in)
    Bibliography.date_to_bibtex!(dict, entry.date)
    Bibliography.access_to_bibtex!(dict, entry.access)
    dict["zotero_export"] = Dates.now()
    dict["zotero_fields"] = entry.fields
    for file in files
        old_file = joinpath(file.filepath, file.filename)
        if !file.isexternal || move_external
            new_file = joinpath(filepath, file.filename)
            if !isfile(old_file)
                @warn "Attachment does not exist." entry.id old_file
                continue
            end
            if isfile(new_file)
                existing_file_sha = open(new_file) do f
                    sha2_256(f)
                end
                old_file_sha = open(old_file) do f
                    sha2_256(f)
                end
                if existing_file_sha == old_file_sha
                    @debug "Duplicate file avoided." entry.id entry.fields["id"]
                    continue
                else
                    new_file_name, new_file_ext = splitext(new_file)
                    new_file = new_file_name * "_" * join(string.(old_file_sha)) * new_file_ext
                end
            end
            cp(old_file, new_file)
            push!(dict["files"], basename(new_file))
        elseif file.isexternal
            push!(dict["files"], old_file)
        end
    end
    for k in keys(dict)
        if dict[k] isa AbstractString && length(dict[k]) == 0
            pop!(dict, k)
        end
    end
    mkpath(filepath)
    info_file = joinpath(filepath, "info.yaml")
    if isfile(info_file)
        @warn "Info file already exist: possible duplicate. Overwriting." info_file entry.fields["id"]
    end
    YAML.write_file(info_file, dict)
end

"""
$(SIGNATURES)

Export the entries generated by [`create_bibinternals`](@ref).
"""
function export_bibinternals(entries; papis_root, showprogress, move_external, append_zotero_id_on_duplicate)
    p = Progress(length(entries); enabled = showprogress, desc = "Exporting $(length(entries)) item(s)...")
    files_created = []
    files_added = Channel(40)
    # This time we can do it concurrently!
    Threads.@threads for (entry, tags, files) in entries
        export_bibinternal(entry, tags, files; papis_root, move_external, append_zotero_id_on_duplicate)
        next!(p, showvalues = [(:Key, entry.id)])
    end
end
