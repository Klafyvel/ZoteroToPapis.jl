"""
$(SIGNATURES)

Export a [`ZoteroEntry`](@ref) entry to Papis, handling some edge cases (duplicates, files not existing...)
"""
function export_zotero_entry(entry; papis_root, move_external, append_zotero_id_on_duplicate)
    filepath = papis_directory(papis_root, entry.year, entry.citationkey)
    if isdir(filepath) && append_zotero_id_on_duplicate
        filepath = papis_directory(papis_root, entry.year, entry.citationkey * "_" * entry.zotero_extra_fields["database_id"])
    end
    problematic_path = []
    if isdir(filepath)
        push!(problematic_path, (filepath, "Unresolved duplicate"))
    end
    mkpath(filepath)
    biblatex_entry = BibLaTeXEntry(entry)
    dict = to_dict(biblatex_entry)
    for (i, file) in enumerate(biblatex_entry.files)
        old_file = joinpath(file.filepath, file.filename)
        if !file.isexternal || move_external
            new_file = joinpath(filepath, file.filename)
            if !isfile(old_file)
                push!(problematic_path, (old_file, "Attachment does not exist."))
                continue
            end
            if isfile(new_file)
                existing_file_sha = open(new_file) do f
                    sha2_256(f)
                end
                old_file_sha = open(old_file) do f
                    sha2_256(f)
                end
                if existing_file_sha == old_file_sha
                    continue
                else
                    new_file_name, new_file_ext = splitext(new_file)
                    new_file = new_file_name * "_" * join(string.(old_file_sha)) * new_file_ext
                end
            end
            cp(old_file, new_file)
            dict["files"][i] = basename(new_file)
        elseif file.isexternal
            dict["files"][i] = old_file
        end
    end
    for k in keys(dict)
        if dict[k] isa AbstractString && length(dict[k]) == 0
            pop!(dict, k)
        end
    end
    mkpath(filepath)
    info_file = joinpath(filepath, "info.yaml")
    if isfile(info_file)
        push!(problematic_path, (info_file, "Info file already exist: possible duplicate. Overwriting."))
    end
    YAML.write_file(info_file, dict)
    problematic_path
end

"""
$(SIGNATURES)

Export the entries generated by [`create_zotero_entries`](@ref).
"""
function export_zotero_entries(entries; papis_root, showprogress, move_external, append_zotero_id_on_duplicate)
    p = Progress(length(entries); enabled = showprogress, desc = "Exporting $(length(entries)) item(s)...")
    files_created = []
    problematic_paths = Channel(length(entries))
    # This time we can do it concurrently!
    Threads.@threads for entry in entries
        problematic_path = export_zotero_entry(entry; papis_root, move_external, append_zotero_id_on_duplicate)
        if !isempty(problematic_path)
            put!(problematic_paths, (entry.citationkey, problematic_path))
        end
        next!(p, showvalues = [(:Key, entry.citationkey)])
    end
    if !isempty(problematic_paths)
        printstyled(stderr, "Warning:", bold = true, color = :yellow)
        println(stderr, " encountered $(length(problematic_paths.data)) errors while exporting database.")
    end
    while !isempty(problematic_paths)
        key, paths = take!(problematic_paths)
        printstyled(stderr, "  â‹… Key ")
        printstyled(stderr, "$key", italic = true)
        print(stderr, ":\n")
        for (path, msg) in paths
            print(stderr, "    - ")
            printstyled(stderr, msg, color = :red)
            print(stderr, "\n      ")
            printstyled(stderr, path, color = :yellow)
            print(stderr, "\n")
        end
    end
end
