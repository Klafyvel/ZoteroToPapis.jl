"""
$(SIGNATURES)

Export a [`ZoteroEntry`](@ref) entry to Papis, handling some edge cases (duplicates, files not existing...)
"""
function export_zotero_entry(entry; papis_root, move_external, append_zotero_id_on_duplicate)
    filepath = papis_directory(papis_root, entry.year, entry.citationkey)
    if isdir(filepath) && append_zotero_id_on_duplicate
        filepath = papis_directory(papis_root, entry.year, entry.citationkey * "_" * entry.zotero_extra_fields["database_id"])
    end
    problematic_path = []
    if isdir(filepath)
        push!(problematic_path, (filepath, "Unresolved duplicate"))
    end
    mkpath(filepath)
    biblatex_entry = BibLaTeXEntry(entry)
    substitute_missing_required!(biblatex_entry)
    dict = to_dict(biblatex_entry)
    for (i, file) in enumerate(biblatex_entry.files)
        old_file = joinpath(file.filepath, file.filename)
        if !file.isexternal || move_external
            new_file = joinpath(filepath, file.filename)
            if !isfile(old_file)
                push!(problematic_path, (old_file, "Attachment does not exist."))
                continue
            end
            if isfile(new_file)
                existing_file_sha = open(new_file) do f
                    sha2_256(f)
                end
                old_file_sha = open(old_file) do f
                    sha2_256(f)
                end
                if existing_file_sha == old_file_sha
                    continue
                else
                    new_file_name, new_file_ext = splitext(new_file)
                    new_file = new_file_name * "_" * join(string.(old_file_sha)) * new_file_ext
                end
            end
            cp(old_file, new_file)
            dict["files"][i] = basename(new_file)
        elseif file.isexternal
            dict["files"][i] = old_file
        end
    end
    for k in keys(dict)
        if dict[k] isa AbstractString && length(dict[k]) == 0
            pop!(dict, k)
        end
    end
    mkpath(filepath)
    info_file = joinpath(filepath, "info.yaml")
    if isfile(info_file)
        push!(problematic_path, (info_file, "Info file already exist: possible duplicate. Overwriting."))
    end
    YAML.write_file(info_file, dict)
    problematic_path, missing_required(biblatex_entry)
end

"""
$(SIGNATURES)

Export the entries generated by [`create_zotero_entries`](@ref).
"""
function export_zotero_entries(entries; papis_root, showprogress, move_external, append_zotero_id_on_duplicate)
    p = Progress(length(entries); enabled = showprogress, desc = "Exporting $(length(entries)) item(s)...")
    files_created = []
    problematic_paths = Channel(length(entries))
    missing_entries = Channel(length(entries))
    # This time we can do it concurrently!
    Threads.@threads for entry in entries
        problematic_path, missing_fields = export_zotero_entry(entry; papis_root, move_external, append_zotero_id_on_duplicate)
        if !isempty(problematic_path)
            put!(problematic_paths, (entry.citationkey, problematic_path))
        end
        if !isempty(missing_fields)
            put!(missing_entries, (entry.citationkey, missing_fields))
        end
        next!(p, showvalues = [(:Key, entry.citationkey)])
    end
    if !isempty(problematic_paths)
        io = IOBuffer()
        write(io, "Encountered $(length(problematic_paths.data)) errors while exporting database.\n")
        while !isempty(problematic_paths)
            key, paths = take!(problematic_paths)
            format_structured_list(
                io, [
                    "Key $key:",
                    ["$msg\n$path" for (path, msg) in paths],
                ],
            )
        end
        @warn String(take!(io))
    end
    if !isempty(missing_entries)
        io = IOBuffer()
        write(io, "The following items are missing required fields:\n")
        while !isempty(missing_entries)
            key, fields = take!(missing_entries)
            joined_fields = join(fields, ",", " and ")
            format_structured_list(
                io, [
                    "Key $key: $(joined_fields)",
                ],
            )
        end
        @warn String(take!(io))
    end
end
